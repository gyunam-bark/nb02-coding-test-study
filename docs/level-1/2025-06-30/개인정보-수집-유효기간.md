# 개인정보 수집 유효기간

## 문제설명

고객의 약관 동의를 얻어서 수집된 1~`n`번으로 분류되는 개인정보 `n`개가 있습니다. 약관 종류는 여러 가지 있으며 각 약관마다 개인정보 보관 유효기간이 정해져 있습니다. 당신은 각 개인정보가 어떤 약관으로 수집됐는지 알고 있습니다. 수집된 개인정보는 유효기간 전까지만 보관 가능하며, 유효기간이 지났다면 반드시 파기해야 합니다.

예를 들어, A라는 약관의 유효기간이 12 달이고, 2021년 1월 5일에 수집된 개인정보가 A 약관으로 수집되었다면 해당 개인정보는 2022년 1월 4일까지 보관 가능하며 2022년 1월 5일부터 파기해야 할 개인정보입니다.
당신은 오늘 날짜로 파기해야 할 개인정보 번호들을 구하려 합니다.

모든 달은 28일까지 있다고 가정합니다.

다음은 오늘 날짜가 `2022.05.19`일 때의 예시입니다.

| 약관 종류 | 유효기간 |
| :-------- | :------- |
| A         | 6달      |
| B         | 12달     |
| C         | 3달      |

| 번호 | 개인정보 수집 일자 | 약관 종류 |
| :--- | :----------------- | :-------- |
| 1    | 2021.05.02         | A         |
| 2    | 2021.07.01         | B         |
| 3    | 2021.02.19         | C         |
| 4    | 2021.02.20         | C         |

- 첫 번째 개인정보는 A약관에 의해 2021년 11월 1일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.
- 두 번째 개인정보는 B약관에 의해 2022년 6월 28일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다.
- 세 번째 개인정보는 C약관에 의해 2022년 5월 18일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.
- 네 번째 개인정보는 C약관에 의해 2022년 5월 19일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다.

따라서 파기해야 할 개인정보 번호는 [1, 3]입니다.

오늘 날짜를 의미하는 문자열 `today`, 약관의 유효기간을 담은 1차원 문자열 배열 `terms`와 수집된 개인정보의 정보를 담은 1차원 문자열 배열 `privacies`가 매개변수로 주어집니다. 이때 파기해야 할 개인정보의 번호를 오름차순으로 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요.

## 제한사항

- today는 "YYYY.MM.DD" 형태로 오늘 날짜를 나타냅니다.
- 1 ≤ terms의 길이 ≤ 20
  - terms의 원소는 "약관 종류 유효기간" 형태의 약관 종류와 유효기간을 공백 하나로 구분한 문자열입니다.
  - 약관 종류는 A~Z중 알파벳 대문자 하나이며, terms 배열에서 약관 종류는 중복되지 않습니다.
  - 유효기간은 개인정보를 보관할 수 있는 달 수를 나타내는 정수이며, 1 이상 100 이하입니다.
- 1 ≤ privacies의 길이 ≤ 100
  - privacies[i]는 i+1번 개인정보의 수집 일자와 약관 종류를 나타냅니다.
  - privacies의 원소는 "날짜 약관 종류" 형태의 날짜와 약관 종류를 공백 하나로 구분한 문자열입니다.
  - 날짜는 "YYYY.MM.DD" 형태의 개인정보가 수집된 날짜를 나타내며, today 이전의 날짜만 주어집니다.
  - privacies의 약관 종류는 항상 terms에 나타난 약관 종류만 주어집니다.
- today와 privacies에 등장하는 날짜의 YYYY는 연도, MM은 월, DD는 일을 나타내며 점(.) 하나로 구분되어 있습니다.
  - 2000 ≤ YYYY ≤ 2022
  - 1 ≤ MM ≤ 12
  - MM이 한 자릿수인 경우 앞에 0이 붙습니다.
  - 1 ≤ DD ≤ 28
  - DD가 한 자릿수인 경우 앞에 0이 붙습니다.
- 파기해야 할 개인정보가 하나 이상 존재하는 입력만 주어집니다.

## 입출력 예

| today        | terms                  | privacies                                                                        | result    |
| :----------- | :--------------------- | :------------------------------------------------------------------------------- | :-------- |
| "2022.05.19" | ["A 6", "B 12", "C 3"] | ["2021.05.02 A", "2021.07.01 B", "2022.02.19 C", "2022.02.20 C"]                 | [1, 3]    |
| "2020.01.01" | ["Z 3", "D 5"]         | ["2019.01.01 D", "2019.11.15 Z", "2019.08.02 D", "2019.07.01 D", "2018.12.28 Z"] | [1, 4, 5] |

## 입출력 예 설명

**입출력 예 #1**

- 문제 예시와 같습니다.

**입출력 예 #2**
| 약관 종류 | 유효기간 |
|:------|:------|
|Z|3 달|
|D|5 달|

| 번호 | 개인정보 수집 일자 | 약관 종류 |
| :--- | :----------------- | :-------- |
| 1    | 2019.01.01         | D         |
| 2    | 2019.11.15         | Z         |
| 3    | 2019.08.02         | D         |
| 4    | 2019.07.01         | D         |
| 5    | 2018.12.28         | Z         |

오늘 날짜는 2020년 1월 1일입니다.

- 첫 번째 개인정보는 D약관에 의해 2019년 5월 28일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.
- 두 번째 개인정보는 Z약관에 의해 2020년 2월 14일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다.
- 세 번째 개인정보는 D약관에 의해 2020년 1월 1일까지 보관 가능하며, 유효기간이 지나지 않았으므로 아직 보관 가능합니다.
- 네 번째 개인정보는 D약관에 의해 2019년 11월 28일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.
- 다섯 번째 개인정보는 Z약관에 의해 2019년 3월 27일까지 보관 가능하며, 유효기간이 지났으므로 파기해야 할 개인정보입니다.

## 제공 코드

```js
function solution(today, terms, privacies) {
  var answer = [];
  return answer;
}
```

## 용어 학습

## 문제 분석

1. terms 테이블 객체 생성

2. praivacies 에서 개인정보 테이블 객체 를 만들어서 배열에 저장

   - today, accept, expire 을 계산해서 isExpired 값을 객체에 저장

3. 개인정보 테이블에서 isExpired 가 true 인 것들의 번호를 모아 반환

## 풀이

```js
let termsTable = {};
let acceptedPrivacyTable = [];

const setTermsTable = (terms) => {
  for (let i = 0; i < terms.length; i++) {
    const term = terms[i];
    const [termName, termRange] = term.split(' ');
    termsTable[termName] = Number(termRange);
  }
};

const stringToDateObject = (date) => {
  const [year, month, day] = date.split('.');

  return Number(year) * 12 * 28 + Number(month) * 28 + Number(day);
};

const checkTermExpired = (today, accept, termType) => {
  let isExpired = false;

  const todayDate = stringToDateObject(today);
  const acceptDate = stringToDateObject(accept);
  const expireDate = acceptDate + termsTable[termType] * 28;

  isExpired = todayDate < expireDate ? false : true;

  return isExpired;
};

const setAcceptedPrivacyTable = (today, privacies) => {
  for (let i = 0; i < privacies.length; i++) {
    const privacy = privacies[i];
    const [accept, termType] = privacy.split(' ');
    const data = {};
    data[accept] = termType;
    data['isExpired'] = checkTermExpired(today, accept, termType);
    acceptedPrivacyTable.push(data);
  }
};

const getExpiredTerms = () => {
  const terms = [];

  for (let i = 0; i < acceptedPrivacyTable.length; i++) {
    const data = acceptedPrivacyTable[i];
    if (data.isExpired) {
      terms.push(i + 1);
    }
  }

  return terms;
};

function solution(today, terms, privacies) {
  let answer = [];
  termsTable = {};
  acceptedPrivacyTable = [];

  setTermsTable(terms);
  setAcceptedPrivacyTable(today, privacies);
  answer = getExpiredTerms();

  return answer;
}
```

## 의문점

MDN: [Array.prototype.map()](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/map#%EC%98%88%EC%A0%9C)

이번에는 map 에 대해서 조금 학습할 수 있었다.

결과부터 말하자면 대다수의 경우엔 반복문을 그냥 쓰는게 정성적인 평가의 감점 요소(?) 는 적을 것 같다.

### map 은 반환값을 사용하는 게 아니라면 사용하지 말 것!

map 은 반환값을 사용하는 게 아니라면 `안티 패턴` 이라고 한다.

```js
// ANTI-PATTERN
const products = [{ name: 'sports car' }, { name: 'laptop' }, { name: 'phone' }];

products.map((product) => {
  product.price = 100;
});
```

위의 예제에서 product.price 를 추가하는 코드는 동작은 하지만, 바람직한 코드는 아니다.

원칙상 map 은 반환값을 통해서 새로운 배열을 만드는 데 사용되어야 한다고 한다.

반환값이 없다면 부작용을 일으킬 수 있기 때문에, 단순 객체를 순환하면서 동작하는 로직의 경우엔 반복문을 사용하는 것을 권장하고 있다.

### map 콜백 부작용

마찬가지로 map 의 콜백도 부작용이 있기 때문에, 순수 함수와 함께 사용하도록 권장하고 있다.

```js
const cart = [5, 15, 25];
let total = 0;
const withTax = cart.map((cost) => {
  total += cost;
  return cost * 1.2;
});
console.log(withTax); // [6, 18, 30]
console.log(total); // 45
```

위의 코드에서 total 을 증가하는 코드 역시 동작은 하지만 바람직한 코드가 아니다.

만약 위와 같은 코드를 작성해야한다면, 아래와 같이 두번에 나눠서 동작하는게 바람직하다.

```js
const cart = [5, 15, 25];
const total = cart.reduce((acc, cost) => acc + cost, 0);
const withTax = cart.map((cost) => cost * 1.2);
```
