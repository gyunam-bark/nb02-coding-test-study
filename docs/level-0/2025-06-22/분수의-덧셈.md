# 분수의 덧셈

## 문제 설명

첫 번째 분수의 분자와 분모를 뜻하는 `numer1`, `denom1`, 두 번째 분수의 분자와 분모를 뜻하는 `numer2`, `denom2`가 매개변수로 주어집니다.

두 분수를 더한 값을 기약 분수로 나타냈을 때 분자와 분모를 순서대로 담은 배열을 return 하도록 solution 함수를 완성해보세요.

## 제한사항

- 0 < `numer1`, `denom1`, `numer2`, `denom2` < 1,000

## 입출력 예

| numer1 | denom1 | numer2 | denom2 | result   |
| :----- | :----- | :----- | :----- | :------- |
| 1      | 2      | 3      | 4      | \[5,4\]  |
| 9      | 2      | 1      | 3      | \[29,6\] |

## 입출력 예 설명

**입출력 예 \#1**

- `1 / 2 + 3 / 4 = 5 / 4` 입니다. 따라서 `[5, 4]` 를 return 합니다.

**입출력 예 \#2**

- `9 / 2 + 1 / 3 = 29 / 6` 입니다. 따라서 `[29, 6]` 을 return 합니다.

## 제공 코드

```javascript
// SOLUTION.JS
function solution(numer1, denom1, numer2, denom2) {
  let answer = [];
  return answer;
}
```

## 용어 학습

### 분자(numer)

numerator

### 분모(denom)

denominator

### 기약 분수

`더 이상 약분이 안 되는 분수` 를 뜻한다.

즉, 분자와 분모의 최대공약수\(GCD\) 가 1인 분수 로 return 되어야 한다.

### 최대공약수(GCD)

Greatest Common Divisor

최대공약수를 구하는 널리 사용되는 방법은 `유클리드 호제법(Euclidean Algorithm)` 이다.

$$
\text{GCD}(A, B) = \text{GCD}(B, A \bmod B)
$$

### 최소공배수(LCM)

Least Common Multiple

$$
\text{LCM}(A, B) = \frac{A \times B}{\text{GCD}(A, B)}
$$

## 문제 분석

1. 분모를 최소공배수로 통일하기

2. 분자를 최소공배수에 맞추기

3. 분자를 더한 값이 분모와 공약수가 없는지 확인

- 공약수가 있을 경우 최대 공약수로 나누어 기약분수로 만듬

4. 반환

## 풀이

```js
// GCD 반환 메서드
const getGcd = (denom1 = 0, denom2 = 0) => {
  while (denom2 !== 0) {
    [denom1, denom2] = [denom2, denom1 % denom2];
  }
  return denom1;
};

// LCM 반환 메서드
const getLcm = (denom1 = 0, denom2 = 0) => {
  if (denom1 === 0 || denom2 === 0) {
    return 0;
  }
  const gcd = getGcd(denom1, denom2);
  return (denom1 * denom2) / gcd;
};

const normalizeNumber = (numer = 0, lcm = 0, denom = 0) => {
  return numer * (lcm / denom);
};

// 기본 제공 솔루션 메서드
function solution(numer1, denom1, numer2, denom2) {
  let answer = [];

  // 최소공배수
  const lcm = getLcm(denom1, denom2);

  // 분모를 최소공배수로 했을 때의 분자 값으로 변경
  const normalizedNumer1 = normalizeNumber(numer1, lcm, denom1);
  const normalizedNumer2 = normalizeNumber(numer2, lcm, denom2);

  // 분모가 같기 때문에 그냥 더함
  const totalNumer = normalizedNumer1 + normalizedNumer2;

  // 더한 값이 lcm 과 공약수가 있을 수 있음
  // 최대공약수를 구해서 나눔
  const gcd = getGcd(totalNumer, lcm);
  const simplifiedNumer = totalNumer / gcd;
  const simplifiedDenom = lcm / gcd;

  answer = [simplifiedNumer, simplifiedDenom];

  return answer;
}
```

## 의문점

1. 왜 float 형이 아니라 \[분자, 분모\] 형태로 return 하는가?

부동소수점(float) 은 정확하게 유리수(분수)를 표현할 수 없기 때문이다.

부동소수점(float)은 근사값으로 저장하는 특징 때문에 사소한 오차가 누적되어서 큰 문제로 번질 수 있는 가능성도 있다.

대부분의 프로그램은 아주 미세한 소숫점 오차에 예민하지 않지만, 우주선이나 비행기 같은 미세한 조종이 필요한 경우에는 이 오차 하나로 큰 사고로 번질 가능성이 있다.
