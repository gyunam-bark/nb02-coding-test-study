# 특이한 정렬

## 문제 설명

정수 `n`을 기준으로 `n`과 가까운 수부터 정렬하려고 합니다. 이때 `n`으로부터의 거리가 같다면 더 큰 수를 앞에 오도록 배치합니다. 정수가 담긴 배열 `numlist`와 정수 `n` 이 주어질 때 `numlist` 의 원소를 `n` 으로부터 가까운 순서대로 정렬한 배열을 return하도록 solution 함수를 완성해주세요.

## 제한사항

- 1 ≤ `n` ≤ 10,000
- 1 ≤ `numlist`의 원소 ≤ 10,000
- 1 ≤ `numlist`의 길이 ≤ 100
- `numlist`는 중복된 원소를 갖지 않습니다.

## 입출력 예

| numlist                         | n   | result                                 |
| :------------------------------ | :-- | :------------------------------------- |
| \[1,2,3,4,5,6\]                 | 4   | \[4,5,3,6,2,1\]                        |
| \[10000,20,36,47,40,6,10,7000\] | 30  | \[36, 40, 20, 47, 10, 6, 7000, 10000\] |

## 입출력 예 설명

**입출력 예 \#1**

- 4에서 가까운 순으로 [4, 5, 3, 6, 2, 1]을 return합니다.
- 3과 5는 거리가 같으므로 더 큰 5가 앞에 와야 합니다.
- 2와 6은 거리가 같으므로 더 큰 6이 앞에 와야 합니다.

**입출력 예 \#2**

- 30에서 가까운 순으로 [36, 40, 20, 47, 10, 6, 7000, 10000]을 return합니다.
- 20과 40은 거리가 같으므로 더 큰 40이 앞에 와야 합니다.

## 제공코드

```js
function solution(numlist, n) {
  let answer = [];
  return answer;
}
```

## 용어학습

### 비교(compare)

array.sort() 내부에 들어가는 메서드는 비교 메서드라고 한다.

간단한 비교 메서드를 아래와 같이 직접 넣는 경우도 많다.

```js
array.sort((l, r) => l - r);
```

그러나 추가적인 조건이나 로직이 들어갈 경우 밖으로 빼내서 작성하는 경우도 있는데, 이때는 직관적으로 이해할 수 있도록 `compare` 로 시작하면 좋다.

### 차이(different) 와 거리(distance)

두 값의 차이를 나타낼 때 `different` 가 자주 사용되지만, `distance` 도 그만큼 자주 사용된다.

둘 중 뭘 사용해도 문제없지만, 이번 문제의 경우에는 n 으로 부터의 거리 라는 느낌이 강해서 distance 를 사용한다.

## 문제 분석

1. array.sort() 사용
2. 각 요소의 n 으로부터의 거리 값으로 비교
   - 거리가 같을 경우, 값이 큰 n 이 먼저
   - 거리가 다를 경우, 값이 작은 distance 먼저

## 풀이

```js
const compareNumlist = (n) => {
  return (left, right) => {
    const distanceLeft = Math.abs(left - n);
    const distanceRight = Math.abs(right - n);

    if (distanceLeft === distanceRight) {
      return right - left;
    } else {
      return distanceLeft - distanceRight;
    }
  };
};

function solution(numlist, n) {
  const array = numlist.sort(compareNumlist(n));

  return array;
}
```

## 의문점

1. array.sort() 내부 비교 메서드 반환값에 대한 고찰

array.sort() 내부 비교 메서드 반환 값은 오로지 `[음수,0,양수]` 인지만 확인한다.

그래서 기본적인 오름차순 정렬은 아래와 같다.

```js
array.sort((l, r) => l - r);
```

좀 더 풀어서 작성하면 아래와 같은 형태가 된다.

```js
array.sort((l, r) => {
  if (l == r) {
    return 0;
  } else if (l > r) {
    return 1; // 양수인지만 체크함
  } else if (l < r) {
    return -1; // 음수인지만 체크함
  }
});
```

그러나 중요한 것은 `양수` 일 때만 자리를 바꾼다는 것을 이해하면 된다!

0 과 음수 일 때는 자리를 이동하지 않는다.

그렇기 때문에 자리를 바꾸는 로직은 언제나 양수가 나오도록 설계해야 한다.
