# 평행

## 문제설명

점 네 개의 좌표를 담은 이차원 배열 `dots` 가 다음과 같이 매개변수로 주어집니다.

- [[x1, y1], [x2, y2], [x3, y3], [x4, y4]]

주어진 네 개의 점을 두 개씩 이었을 때, 두 직선이 평행이 되는 경우가 있으면 1을 없으면 0을 return 하도록 solution 함수를 완성해보세요.

## 제한사항

- `dots` 의 길이 = 4
- `dots` 의 원소는 [x, y] 형태이며 x, y는 정수입니다.
  - 0 ≤ x, y ≤ 100
- 서로 다른 두개 이상의 점이 겹치는 경우는 없습니다.
- 두 직선이 겹치는 경우(일치하는 경우)에도 1을 return 해주세요.
- 임의의 두 점을 이은 직선이 x축 또는 y축과 평행한 경우는 주어지지 않습니다.

## 입출력 예

| dots                              | result |
| :-------------------------------- | :----- |
| [[1, 4], [9, 2], [3, 8], [11, 6]] | 1      |
| [[3, 5], [4, 1], [2, 4], [5, 10]] | 0      |

## 입출력 예 설명

**입출력 예 #1**

- 점 [1, 4], [3, 8]을 잇고 [9, 2], [11, 6]를 이으면 두 선분은 평행합니다.

**입출력 예 #2**

- 점을 어떻게 연결해도 평행하지 않습니다.

## 제공코드

```js
function solution(dots) {
  let answer = 0;
  return answer;
}
```

## 용어학습

### 기울기(slope)

기울기를 구할 때는 `기울기-절편 공식(slope-itercept formula)` 을 사용할 수 있다.

> y = mx + b

이건 어떤 직선의 공통적인 방정식으로 이 직선의 경로에 있는 점(x,y) 라면 어떤 점이더라도 이 공식을 만족해야 한다.

그래서 두 개의 점을 이어서 선을 만들기 때문에 기울기-방정식도 두 개가 된다.

> y1 = mx1 + b  
> y2 = mx2 + b

여기서 우리가 구해야 하는 것이 `m(기울기)` 이기 때문에 두 방정식을 뺀다.

> y2 - y1 = m(x2 - x1)

그리고 (x2 - x1) 을 나누면 `m` 만 남게 된다.

> m = (y2 - y1)/(x2 - x1)

단, 후항(x - x) 가 0이 되면 안 된다.(무한대가 되기 때문)

## 문제분석

1. 점의 갯수는 총 4개, 그 중에서 선을 만들 수 있는 경우의 수는 단 4가지 뿐이다.
   - 순서가 다른 같은 선 2개가 빠짐
2. 4 가지의 경우의 수에서 두 선의 기울기가 같다면 1, 아니면 0 을 반환한다.

## 풀이

```js
class Dot {
  x;
  y;
  constructor(dot) {
    [this.x, this.y] = dot;
  }
}

class Line {
  #begin;
  #end;

  constructor(dots) {
    [this.#begin, this.#end] = dots;
  }

  slope() {
    const yIntercept = this.#end.y - this.#begin.y;
    const xIntercept = this.#end.x - this.#begin.x;

    if (xIntercept === 0) {
      return Infinity;
    }

    return yIntercept / xIntercept;
  }
}

const compareLine = (combination, dotList) => {
  const lineList = combination.map((indexList) => {
    const dots = indexList.map((index) => dotList[index]);
    return new Line(dots);
  });

  if (lineList[0].slope() === lineList[1].slope()) {
    return true;
  }

  return false;
};

function solution(dots) {
  let answer = 0;

  const dotList = dots.map((dot) => new Dot(dot));

  const combinations = [
    [
      [0, 1],
      [2, 3],
    ],
    [
      [0, 2],
      [1, 3],
    ],
    [
      [0, 3],
      [1, 2],
    ],
  ];

  for (const combination of combinations) {
    if (compareLine(combination, dotList)) {
      answer = 1;
      break;
    }
  }

  return answer;
}
```

## 의문점

### 만약 주어진 점의 갯수가 4개 보다 많은 수 였다면?

이번에는 단 4개의 점이었기 때문에 직접 종이에 적으면서 경우의 수를 정리할 수 있었다.

그런데 만약, 주어진 점의 갯수가 4개 보다 많다면 어떻게 해야할까?

이럴 때는 `조합` 이라는 알고리즘을 사용해야 한다.

```js
function getCombinations(array, size) {
  const result = [];

  function combine(temp, start) {
    if (temp.length === size) {
      result.push([...temp]);
      return;
    }

    for (let i = start; i < array.length; i++) {
      temp.push(array[i]);
      combine(temp, i + 1);
      temp.pop();
    }
  }

  combine([], 0);
  return result;
}
```

조합 알고리즘의 경우엔 반복문으로도 만들 수는 있다.

그러나 주어지는 데이터의 형식에 따라서 굉장히 많은 중첩문을 가지기 때문에 가독성과 효율성이 떨어진다고 생각한다.
